#include <bits/stdc++.h>
using namespace std;

const int INF = 1e9;

struct Edge {
	int to, capacity, flow, cost, rev;
};

vector<vector<Edge>> adj;
int N, M, source, sink, cap[101][101];

void addEdge(int u, int v, int capacity, int cost) {
	Edge a{ v, capacity, 0, cost, (int)adj[v].size() };
	Edge b{ u, 0, 0, -cost, (int)adj[u].size() };
	adj[u].push_back(a);
	adj[v].push_back(b);
}

pair<int, int> mcmf() {
	int total_cost = 0, total_flow = 0;
	int total_nodes = N + M + 2; // 전체 노드 수

	while (true) {
		vector<int> dist(total_nodes, INF), parent(total_nodes, -1), parentEdge(total_nodes, -1);
		vector<bool> inQueue(total_nodes, false);
		vector<int> cnt(total_nodes, 0); // 각 노드가 큐에 들어온 횟수
		queue<int> q;

		dist[source] = 0;
		q.push(source);
		inQueue[source] = true;
		cnt[source]++;

		while (!q.empty()) {
			int u = q.front();
			q.pop();
			inQueue[u] = false;

			for (int i = 0; i < adj[u].size(); i++) {
				Edge& e = adj[u][i];
				if (e.flow < e.capacity && dist[u] + e.cost < dist[e.to]) {
					dist[e.to] = dist[u] + e.cost;
					parent[e.to] = u;
					parentEdge[e.to] = i;
					if (!inQueue[e.to]) {
						q.push(e.to);
						inQueue[e.to] = true;
						cnt[e.to]++;
						// 음수 사이클 감지: 특정 노드가 너무 많이 큐에 들어오면 무한 루프임
						if (cnt[e.to] >= total_nodes) {
							goto end_spfa; // SPFA 종료
						}
					}
				}
			}
		}
	end_spfa:; // goto를 위한 레이블

		if (dist[sink] == INF) break;
		int flow = INF;
		for (int u = sink; u != source; u = parent[u]) {
			Edge& e = adj[parent[u]][parentEdge[u]];
			flow = min(flow, e.capacity - e.flow);
		}
		for (int u = sink; u != source; u = parent[u]) {
			Edge& e = adj[parent[u]][parentEdge[u]];
			e.flow += flow;
			adj[e.to][e.rev].flow -= flow;
		}
		total_cost += flow * dist[sink];
		total_flow += flow;
	}
	return { total_flow, total_cost };
}

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin >> N >> M;
	adj.resize(N + M + 2);
	source = 0;
	sink = N + M + 1;

	for (int i = 1; i <= N; i++) {
		int demand; cin >> demand;
		addEdge(M + i, sink, demand, 0);
	}

	for (int i = 1; i <= M; i++) {
		int supply; cin >> supply;
		addEdge(source, i, supply, 0);
	}

	for (int i = 1; i <= M; i++) {
		for (int j = 1; j <= N; j++) {
			cin >> cap[i][j];
		}
	}

	for (int i = 1; i <= M; i++) {
		for (int j = 1; j <= N; j++) {
			int cost; cin >> cost;
			addEdge(i, M + j, cap[i][j], cost);
		}
	}
	auto [flow, cost] = mcmf();
	cout << flow << '\n' << cost;
}