#include <bits/stdc++.h>
using namespace std;

/**
 * Fenwick Tree (Binary Indexed Tree)
 * Time Complexity: O(log N)
 * Space Complexity: O(N)
 * 1-based indexing
 */
template <typename T = long long>
struct FenwickTree {
    int n;
    vector<T> tree;

    FenwickTree(int size) : n(size), tree(size + 1, 0) {}

    void update(int idx, T diff) {
        while (idx <= n) {
            tree[idx] += diff;
            idx += (idx & -idx);
        }
    }

    T query(int idx) {
        T sum = 0;
        while (idx > 0) {
            sum += tree[idx];
            idx -= (idx & -idx);
        }
        return sum;
    }
};

int main() {
    cin.tie(0)->sync_with_stdio(0);
    int n; cin >> n;
    FenwickTree<long long> fenwick(n), fenwick2(n);
    
    long long prev = 0;
    for (int i = 1; i <= n; i++) {
        long long val; cin >> val;
        fenwick.update(i, val - prev);
        fenwick.update(i + 1, -(val - prev));
        fenwick2.update(i, (i - 1) * (val - prev));
        fenwick2.update(i + 1, -i * (val - prev));
        prev = val;
    }

    int q; cin >> q; while (q--) {
        int type; cin >> type;
        if (type == 1) {
            int l, r; cin >> l >> r;
            fenwick.update(l, 1);
            fenwick.update(r + 1, -1);
            fenwick2.update(l, l - 1);
            fenwick2.update(r + 1, -r);

            if (r + 1 <= n) {
                long long height = (long long)(r - l + 1);
                fenwick.update(r + 1, -height);
                fenwick.update(r + 2, height);
                fenwick2.update(r + 1, -r * height);
                fenwick2.update(r + 2, (r + 1) * height);
            }
        }
        else if (type == 2) {
            int x; cin >> x;
            cout << fenwick.query(x) * x - fenwick2.query(x) << '\n';
        }
    }
}