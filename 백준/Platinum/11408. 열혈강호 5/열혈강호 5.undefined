#include <bits/stdc++.h>
using namespace std;

const int INF = 1e9;

struct Edge {
	int to, capacity, flow, cost, rev;
};

vector<vector<Edge>> adj;
int N, M, source, sink;

void addEdge(int u, int v, int capacity, int cost) {
	Edge a{ v, capacity, 0, cost, (int)adj[v].size() };
	Edge b{ u, 0, 0, -cost, (int)adj[u].size() };
	adj[u].push_back(a);
	adj[v].push_back(b);
}

pair<int, int> mcmf() {
	int total_cost = 0, total_flow = 0;
	while (true) {
		vector<int> dist(N + M + 2, INF), parent(N + M + 2, -1), parentEdge(N + M + 2, -1);
		vector<bool> inQueue(N + M + 2, false);
		queue<int> q;

		dist[source] = 0;
		q.push(source);
		inQueue[source] = true;
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			inQueue[u] = false;
			for (int i = 0; i < adj[u].size(); i++) {
				Edge& e = adj[u][i];
				if (e.flow < e.capacity && dist[u] + e.cost < dist[e.to]) {
					dist[e.to] = dist[u] + e.cost;
					parent[e.to] = u;
					parentEdge[e.to] = i;
					if (!inQueue[e.to]) {
						q.push(e.to);
						inQueue[e.to] = true;
					}
				}
			}
		}
		if (dist[sink] == INF) break;
		int flow = INF;
		for (int u = sink; u != source; u = parent[u]) {
			Edge& e = adj[parent[u]][parentEdge[u]];
			flow = min(flow, e.capacity - e.flow);
		}
		for (int u = sink; u != source; u = parent[u]) {
			Edge& e = adj[parent[u]][parentEdge[u]];
			e.flow += flow;
			adj[e.to][e.rev].flow -= flow;
		}
		total_cost += flow * dist[sink];
		total_flow += flow;
	}
	return { total_flow, total_cost };
}

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin >> N >> M;
	adj.resize(N + M + 2);
	source = 0;
	sink = N + M + 1;

	for (int i = 1; i <= N; i++)
		addEdge(source, i, 1, 0);

	for (int i = 1; i <= M; i++)
		addEdge(N + i, sink, 1, 0);

	for (int i = 1; i <= N; i++) {
		int n; cin >> n;
		for (int j = 0; j < n; j++) {
			int v, cost; cin >> v >> cost;
			addEdge(i, N + v, 1, cost);
		}
	}

	auto [flow, cost] = mcmf();
	cout << flow << '\n' << cost;
}